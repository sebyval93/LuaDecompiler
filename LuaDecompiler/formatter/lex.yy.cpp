// lex.yy.cpp generated by reflex 0.9.27 from lua_format.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_outfile             lex.yy.cpp
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define YY_NUM_RULES (22)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual int yylex();
  int yylex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "lua_format.l"


    #include <formatter.h>

	Formatter& format = Formatter::getInstance();



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int yyFlexLexer::yylex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 7: (?:(?:\Q--\E).*)
            YY_USER_ACTION
#line 7 "lua_format.l"
{

    format.comment(std::string(yytext), false);

}


            YY_BREAK
          case 2: // rule at line 11: (?:[\x5b][\x5b][^\x5d]*[\x5d]+)
            YY_USER_ACTION
#line 11 "lua_format.l"
{

	// TODO: handle nested [[ [[ ]] ]]

    format.comment(std::string(yytext), true);

}


            YY_BREAK
          case 3: // rule at line 16: (?:"(?:\\.|[^"\x5c])*")
            YY_USER_ACTION
#line 16 "lua_format.l"
{

    format.string(std::string(yytext));

}


            YY_BREAK
          case 4: // rule at line 20: (?:\Q;\E)
            YY_USER_ACTION
#line 20 "lua_format.l"
{

    format.semicolon(std::string(yytext));

    unput('\n');

}


            YY_BREAK
          case 5: // rule at line 25: (?:(?:\Q})\E)[\x29]+[,][\x20])
            YY_USER_ACTION
#line 25 "lua_format.l"
{

    format.tableEnd(std::string(yytext));

}


            YY_BREAK
          case 6: // rule at line 29: (?:(?:\Q})\E)[\x29]+[,])
            YY_USER_ACTION
#line 29 "lua_format.l"
{

    format.tableEnd(std::string(yytext));

}


            YY_BREAK
          case 7: // rule at line 33: (?:(?:\Q})\E)[\x29]+)
            YY_USER_ACTION
#line 33 "lua_format.l"
{

    format.tableEnd(std::string(yytext));

}


            YY_BREAK
          case 8: // rule at line 37: (?:\Q({\E)
            YY_USER_ACTION
#line 37 "lua_format.l"
{

    unput('{');

}


            YY_BREAK
          case 9: // rule at line 41: (?:\Q{ \E)
            YY_USER_ACTION
#line 41 "lua_format.l"
{

    unput('{');

}


            YY_BREAK
          case 10: // rule at line 45: (?:\Q{\E)
            YY_USER_ACTION
#line 45 "lua_format.l"
{

    format.tableStart(std::string(yytext));

    unput('\n');

}


            YY_BREAK
          case 11: // rule at line 50: (?:\Q})\E)
            YY_USER_ACTION
#line 50 "lua_format.l"
{

    unput('}');

}


            YY_BREAK
          case 12: // rule at line 54: (?:\Q}, \E)
            YY_USER_ACTION
#line 54 "lua_format.l"
{

    unput(',');

    unput('}');

}


            YY_BREAK
          case 13: // rule at line 59: (?:\Q},\E)
            YY_USER_ACTION
#line 59 "lua_format.l"
{

    format.tableEnd(std::string(yytext));

    unput('\n');

}


            YY_BREAK
          case 14: // rule at line 64: (?:\Q}\E)
            YY_USER_ACTION
#line 64 "lua_format.l"
{

    format.tableEnd(std::string(yytext));

}


            YY_BREAK
          case 15: // rule at line 68: (?:\Q, \E)
            YY_USER_ACTION
#line 68 "lua_format.l"
{

    if (format.isWithinTable())

    {

        unput(',');

    }

    else

        format.comma(std::string(yytext));

}


            YY_BREAK
          case 16: // rule at line 77: (?:\Q,\E)
            YY_USER_ACTION
#line 77 "lua_format.l"
{

	format.comma(std::string(yytext));

    if (format.isWithinTable())

    {

        unput('\n');

    }

}


            YY_BREAK
          case 17: // rule at line 85: ^(?:function.*)
            YY_USER_ACTION
#line 85 "lua_format.l"
{

    format.functionStart(std::string(yytext));

}


            YY_BREAK
          case 18: // rule at line 89: ^(?:if.*(?:then))
            YY_USER_ACTION
#line 89 "lua_format.l"
{

    format.conditionStart(std::string(yytext));

}


            YY_BREAK
          case 19: // rule at line 93: ^(?:for.*(?:do))
            YY_USER_ACTION
#line 93 "lua_format.l"
{

	format.forLoopStart(std::string(yytext));

}


            YY_BREAK
          case 20: // rule at line 97: ^(?:end.*)
            YY_USER_ACTION
#line 97 "lua_format.l"
{

    format.blockEnd(std::string(yytext));

}


            YY_BREAK
          case 21: // rule at line 101: (?:\n)
            YY_USER_ACTION
#line 101 "lua_format.l"
{

    format.newLine(std::string(yytext));

}


            YY_BREAK
          case 22: // rule at line 105: .
            YY_USER_ACTION
#line 105 "lua_format.l"
{

    format.anyChar(std::string(yytext));

}
            YY_BREAK
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '}') goto S25;
  if (c1 == '{') goto S32;
  if (c1 == 'i') goto S42;
  if (c1 == 'f') goto S38;
  if (c1 == 'e') goto S45;
  if (c1 == '[') goto S16;
  if (c1 == ';') goto S23;
  if (c1 == '-') goto S13;
  if (c1 == ',') goto S35;
  if (c1 == '(') goto S29;
  if (c1 == '"') goto S19;
  if (c1 == '\n') goto S48;
  if ('\0' <= c1) goto S50;
  return m.FSM_HALT(c1);

S13:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '-') goto S52;
  return m.FSM_HALT(c1);

S16:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '[') goto S56;
  return m.FSM_HALT(c1);

S19:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S60;
  if (c1 == '"') goto S58;
  if ('\0' <= c1) goto S63;
  return m.FSM_HALT(c1);

S23:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S25:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ',') goto S69;
  if (c1 == ')') goto S66;
  return m.FSM_HALT(c1);

S29:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '{') goto S72;
  return m.FSM_HALT(c1);

S32:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S74;
  return m.FSM_HALT(c1);

S35:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S76;
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S78;
  if (c1 == 'o') goto S80;
  return m.FSM_HALT(c1);

S42:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'f') goto S82;
  return m.FSM_HALT(c1);

S45:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S86;
  return m.FSM_HALT(c1);

S48:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S50:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S52:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S52;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S52;
  return m.FSM_HALT(c1);

S56:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S88;
  if ('\0' <= c1) goto S56;
  return m.FSM_HALT(c1);

S58:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S60:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S63;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S63;
  return m.FSM_HALT(c1);

S63:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S60;
  if (c1 == '"') goto S58;
  if ('\0' <= c1) goto S63;
  return m.FSM_HALT(c1);

S66:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S91;
  return m.FSM_HALT(c1);

S69:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S95;
  return m.FSM_HALT(c1);

S72:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S74:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S76:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S78:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S97;
  return m.FSM_HALT(c1);

S80:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S99;
  return m.FSM_HALT(c1);

S82:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S103;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S86:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S108;
  return m.FSM_HALT(c1);

S88:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S88;
  return m.FSM_HALT(c1);

S91:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ',') goto S112;
  if (c1 == ')') goto S91;
  return m.FSM_HALT(c1);

S95:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S97:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S115;
  return m.FSM_HALT(c1);

S99:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S117;
  if ('\v' <= c1) goto S99;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S99;
  return m.FSM_HALT(c1);

S103:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S103;
  if (c1 == 'h') goto S122;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S108:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(20, c1);
  }
  if ('\v' <= c1) goto S108;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S108;
  return m.FSM_HALT(c1);

S112:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S129;
  return m.FSM_HALT(c1);

S115:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S131;
  return m.FSM_HALT(c1);

S117:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S133;
  if (c1 == 'd') goto S117;
  if ('\v' <= c1) goto S99;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S99;
  return m.FSM_HALT(c1);

S122:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S103;
  if (c1 == 'e') goto S138;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S127:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S129:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S131:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S143;
  return m.FSM_HALT(c1);

S133:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(19, c1);
  }
  if (c1 == 'd') goto S117;
  if ('\v' <= c1) goto S99;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S99;
  return m.FSM_HALT(c1);

S138:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S103;
  if (c1 == 'n') goto S147;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S143:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S152;
  return m.FSM_HALT(c1);

S145:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S147:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(18, c1);
  }
  if (c1 == 't') goto S103;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S152:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S156;
  return m.FSM_HALT(c1);

S154:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S156:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(17, c1);
  }
  if ('\v' <= c1) goto S156;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S156;
  return m.FSM_HALT(c1);

S160:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);
}

