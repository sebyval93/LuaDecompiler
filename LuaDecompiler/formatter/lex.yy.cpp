// lex.yy.cpp generated by reflex 0.9.27 from lua_format.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_lex                 yylex
#define REFLEX_OPTION_lexer               yyFlexLexer
#define REFLEX_OPTION_outfile             lex.yy.cpp
#define REFLEX_OPTION_prefix              yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define YY_NUM_RULES (25)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>
typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class yyFlexLexer : public FlexLexer {
 public:
  yyFlexLexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream        *os    = NULL)
    :
      FlexLexer(input, os)
  {
  }
  virtual int yylex();
  int yylex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return yylex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "lua_format.l"


    #include <formatter.h>

	Formatter& format = Formatter::getInstance();



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);

int yyFlexLexer::yylex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule at line 7: (?:(?:\Q--\E).*)
            YY_USER_ACTION
#line 7 "lua_format.l"
{

    //printf("%s", yytext);

	format.appendStr(yytext);

}


            YY_BREAK
          case 2: // rule at line 12: (?:[\x5b][\x5b][^\x5d]*[\x5d]+(?:[^\x5d][^\x5d]*[\x5d]+)*[\x5d])
            YY_USER_ACTION
#line 12 "lua_format.l"
{

    format.appendStr(yytext);

}


            YY_BREAK
          case 3: // rule at line 16: (?:"(?:\\.|[^"\x5c])*")
            YY_USER_ACTION
#line 16 "lua_format.l"
{

    format.appendStr(yytext);

}


            YY_BREAK
          case 4: // rule at line 20: (?:\Q;\E)
            YY_USER_ACTION
#line 20 "lua_format.l"
{

    //printf("%s", yytext);

    format.appendStr(yytext);

    unput('\n');

}


            YY_BREAK
          case 5: // rule at line 26: (?:\Q})))\E)
            YY_USER_ACTION
#line 26 "lua_format.l"
{

	format.decreaseParan();

	format.decreaseIndent();

    //printf("\n%s}))", format.generateIndent());

    format.appendStr("\n").append(format.generateIndent()).append("}))");

}


            YY_BREAK
          case 6: // rule at line 33: (?:\Q}))\E)
            YY_USER_ACTION
#line 33 "lua_format.l"
{

	format.decreaseParan();

	format.decreaseIndent();

    //printf("\n%s})", generateIndent());

    format.appendStr("\n").append(format.generateIndent()).append("})");

}


            YY_BREAK
          case 7: // rule at line 40: (?:\Q}))), \E)
            YY_USER_ACTION
#line 40 "lua_format.l"
{

	format.decreaseParan();

	format.decreaseIndent();

    //printf("\n%s}),\n%s", generateIndent(), generateIndent());

    format.appendStr("\n" + format.generateIndent() + "})),\n" + format.generateIndent());

}


            YY_BREAK
          case 8: // rule at line 47: (?:\Q})), \E)
            YY_USER_ACTION
#line 47 "lua_format.l"
{

	format.decreaseParan();

	format.decreaseIndent();

    //printf("\n%s}),\n%s", generateIndent(), generateIndent());

    format.appendStr("\n" + format.generateIndent() + "}),\n" + format.generateIndent());

}


            YY_BREAK
          case 9: // rule at line 54: (?:\Q})),\E)
            YY_USER_ACTION
#line 54 "lua_format.l"
{

	format.decreaseParan();

	format.decreaseIndent();

    //printf("\n%s}),\n%s", generateIndent(), generateIndent());

    format.appendStr("\n" + format.generateIndent() + "}),\n" + format.generateIndent());

}


            YY_BREAK
          case 10: // rule at line 61: (?:\Q({\E)
            YY_USER_ACTION
#line 61 "lua_format.l"
{

    unput('{');

}


            YY_BREAK
          case 11: // rule at line 65: (?:\Q{ \E)
            YY_USER_ACTION
#line 65 "lua_format.l"
{

    unput('{');

}


            YY_BREAK
          case 12: // rule at line 69: (?:\Q{\E)
            YY_USER_ACTION
#line 69 "lua_format.l"
{

    //printf("\n%s%s", generateIndent(), yytext);

    format.appendStr("\n" + format.generateIndent() + yytext);

    format.increaseIndent();

	format.setWithinTable(true);

    unput('\n');

}


            YY_BREAK
          case 13: // rule at line 77: (?:\Q})\E)
            YY_USER_ACTION
#line 77 "lua_format.l"
{

    unput('}');

}


            YY_BREAK
          case 14: // rule at line 81: (?:\Q}, \E)
            YY_USER_ACTION
#line 81 "lua_format.l"
{

    unput(',');

    unput('}');

}


            YY_BREAK
          case 15: // rule at line 86: (?:\Q},\E)
            YY_USER_ACTION
#line 86 "lua_format.l"
{

	format.decreaseIndent();

    //printf("\n%s%s", generateIndent(), yytext);

    format.appendStr("\n" + format.generateIndent() + yytext);

	format.setWithinTable(false);

    unput('\n');

}


            YY_BREAK
          case 16: // rule at line 94: (?:\Q}\E)
            YY_USER_ACTION
#line 94 "lua_format.l"
{

    format.decreaseIndent();

    //printf("\n%s%s", generateIndent(), yytext);

    format.appendStr("\n" + format.generateIndent() + yytext);

    format.setWithinTable(false);

    //unput('\n');

}


            YY_BREAK
          case 17: // rule at line 102: (?:\Q(\E)
            YY_USER_ACTION
#line 102 "lua_format.l"
{

	format.increaseParan();

    //printf("%s", yytext);

    format.appendStr(yytext);

}


            YY_BREAK
          case 18: // rule at line 108: (?:\Q)\E)
            YY_USER_ACTION
#line 108 "lua_format.l"
{

    format.decreaseParan();

    //printf("%s", yytext);

    format.appendStr(yytext);

}


            YY_BREAK
          case 19: // rule at line 114: (?:\Q, \E)
            YY_USER_ACTION
#line 114 "lua_format.l"
{

    if (format.isWithinTable())

    {

        unput(',');

    }

    else

        format.appendStr(yytext);

        //printf("%s", yytext);

}


            YY_BREAK
          case 20: // rule at line 124: (?:\Q,\E)
            YY_USER_ACTION
#line 124 "lua_format.l"
{

    if (format.isWithinTable())

    {

        //printf("%s", yytext);

        format.appendStr(yytext);

        unput('\n');

    }

    else

        format.appendStr(yytext);

        //printf("%s", yytext);

}


            YY_BREAK
          case 21: // rule at line 136: ^(?:function.*)
            YY_USER_ACTION
#line 136 "lua_format.l"
{

    format.increaseIndent();

    //printf("%s", yytext);

    format.appendStr(yytext);

}


            YY_BREAK
          case 22: // rule at line 142: ^(?:if.*(?:then))
            YY_USER_ACTION
#line 142 "lua_format.l"
{

    format.increaseIndent();

    //printf("%s", yytext);

    format.appendStr(yytext);

}


            YY_BREAK
          case 23: // rule at line 148: ^(?:end.*)
            YY_USER_ACTION
#line 148 "lua_format.l"
{

    format.decreaseIndent();

    // because regex is hard :/

    // deletes the extra tab before the "end" keyword

    //fseek(outputFile, -1, SEEK_CUR);

    //printf("%s\n", yytext);

	format.removeLastChar();

    format.appendStr(yytext).append("\n");

}


            YY_BREAK
          case 24: // rule at line 158: (?:\n)
            YY_USER_ACTION
#line 158 "lua_format.l"
{

    //printf("\n%s", generateIndent());

    format.appendStr("\n").append(format.generateIndent());

}


            YY_BREAK
          case 25: // rule at line 163: .
            YY_USER_ACTION
#line 163 "lua_format.l"
{

    //printf("%s", yytext);

    format.appendStr(yytext);

}
            YY_BREAK
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '}') goto S26;
  if (c1 == '{') goto S33;
  if (c1 == 'i') goto S44;
  if (c1 == 'f') goto S41;
  if (c1 == 'e') goto S47;
  if (c1 == '[') goto S17;
  if (c1 == ';') goto S24;
  if (c1 == '-') goto S14;
  if (c1 == ',') goto S38;
  if (c1 == ')') goto S36;
  if (c1 == '(') goto S30;
  if (c1 == '"') goto S20;
  if (c1 == '\n') goto S50;
  if ('\0' <= c1) goto S52;
  return m.FSM_HALT(c1);

S14:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '-') goto S54;
  return m.FSM_HALT(c1);

S17:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '[') goto S58;
  return m.FSM_HALT(c1);

S20:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S62;
  if (c1 == '"') goto S60;
  if ('\0' <= c1) goto S65;
  return m.FSM_HALT(c1);

S24:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S26:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ',') goto S71;
  if (c1 == ')') goto S68;
  return m.FSM_HALT(c1);

S30:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '{') goto S74;
  return m.FSM_HALT(c1);

S33:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S76;
  return m.FSM_HALT(c1);

S36:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S78;
  return m.FSM_HALT(c1);

S41:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S80;
  return m.FSM_HALT(c1);

S44:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'f') goto S82;
  return m.FSM_HALT(c1);

S47:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S86;
  return m.FSM_HALT(c1);

S50:
  m.FSM_TAKE(24);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S52:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S54:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S54;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S54;
  return m.FSM_HALT(c1);

S58:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S88;
  if ('\0' <= c1) goto S58;
  return m.FSM_HALT(c1);

S60:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S62:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S65;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S65;
  return m.FSM_HALT(c1);

S65:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\\') goto S62;
  if (c1 == '"') goto S60;
  if ('\0' <= c1) goto S65;
  return m.FSM_HALT(c1);

S68:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S90;
  return m.FSM_HALT(c1);

S71:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S94;
  return m.FSM_HALT(c1);

S74:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S76:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S78:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S80:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S96;
  return m.FSM_HALT(c1);

S82:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S98;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S86:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S103;
  return m.FSM_HALT(c1);

S88:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S107;
  if ('\0' <= c1) goto S110;
  return m.FSM_HALT(c1);

S90:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ',') goto S115;
  if (c1 == ')') goto S112;
  return m.FSM_HALT(c1);

S94:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S96:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'c') goto S118;
  return m.FSM_HALT(c1);

S98:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S98;
  if (c1 == 'h') goto S120;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S103:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(23, c1);
  }
  if ('\v' <= c1) goto S103;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S103;
  return m.FSM_HALT(c1);

S107:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S107;
  if ('\0' <= c1) goto S110;
  return m.FSM_HALT(c1);

S110:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S127;
  if ('\0' <= c1) goto S110;
  return m.FSM_HALT(c1);

S112:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ',') goto S129;
  return m.FSM_HALT(c1);

S115:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S131;
  return m.FSM_HALT(c1);

S118:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S133;
  return m.FSM_HALT(c1);

S120:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S98;
  if (c1 == 'e') goto S135;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S125:
  m.FSM_TAKE(23);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S127:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S140;
  if ('\0' <= c1) goto S110;
  return m.FSM_HALT(c1);

S129:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S143;
  return m.FSM_HALT(c1);

S131:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S133:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S145;
  return m.FSM_HALT(c1);

S135:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S98;
  if (c1 == 'n') goto S147;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S140:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S140;
  if ('\0' <= c1) goto S110;
  return m.FSM_HALT(c1);

S143:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S145:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S152;
  return m.FSM_HALT(c1);

S147:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(22, c1);
  }
  if (c1 == 't') goto S98;
  if ('\v' <= c1) goto S82;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S82;
  return m.FSM_HALT(c1);

S152:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S156;
  return m.FSM_HALT(c1);

S154:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S156:
  c0 = c1, c1 = m.FSM_CHAR();
  if (m.FSM_META_BOL()) {
    m.FSM_TAKE(21, c1);
  }
  if ('\v' <= c1) goto S156;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S156;
  return m.FSM_HALT(c1);

S160:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);
}

